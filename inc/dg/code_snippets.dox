#error Documentation only


/**
 * @class hide_code_evaluate2d
 * This code snippet demonstrates how to discretize and compute the norm of a function on a shared memory system
@code{.cpp}
// define the function to integrate
double function(double x, double y, double amp){
    return amp*exp(x)*exp(y);
}

// create a grid of the domain [0,2]x[0,2] with 20 cells in x and y and 3 polynomial coefficients
dg::Grid2d g2d( 0, 2, 0, 2, 3, 20, 20);

// create the Gaussian weights (volume form) for the integration
const dg::HVec w2d = dg::create::weights( g2d);

// our function needs to depend only on x and y so let's fix the amplitude to 2
using namespace std::placeholders; //for _1, _2
auto functor = std::bind( function, _1, _2, 2.);

// discretize the function on the grid
const dg::HVec vec = dg::evaluate( functor, g2d);

// now compute the scalar product (the L2 norm)
double norm = dg::blas2::dot( vec, w2d, vec);

// norm is now: (e^4-1)^2
@endcode

 * @class hide_code_mpi_evaluate2d
 * This code snippet demonstrates how to discretize and compute the norm of a function on a distributed memory system
@code{.cpp}
//define the function to integrate
double function(double x, double y, double amp){
    return amp*exp(x)*exp(y);
}

// create a grid of the domain [0,2]x[0,2] with 20 cells in x and y and 3 polynomial coefficients
//... use MPI_Cart_create to create 2d Cartesian communicator
dg::MPIGrid2d g2d( 0, 2, 0, 2, 3, 20, 20, comm2d);

// create the Gaussian weights (volume form) for the integration
const dg::MHVec w2d = dg::create::weights( g2d);

// our function needs to depend only on x and y so let's fix the amplitude to 2
using namespace std::placeholders; //for _1, _2
auto functor = std::bind( function, _1, _2, 2.);

// discretize the function on the grid
const dg::MHVec vec = dg::evaluate( functor, g2d);

// multiply and sum the results
double norm = dg::blas2::dot( vec, w2d, vec);

// norm is now: (e^4-1)^2
@endcode

 * @class hide_code_blas2_symv
 * This code snippet demonstrates how to derive a function on a device
@code{.cpp}
//define a function to derive
double function(double x, double y){
    return sin(x)*sin(y);
}

//create a grid of the domain [0,2]x[0,2] with 20 cells in x and y and 3 polynomial coefficients
dg::Grid2d g2d( 0, 2, 0, 2, 3, 20, 20, dg::DIR);

//declare a device matrix
dg::DMatrix dx;

//create the x derivative on the grid and transfer the matrix to the device
dg::blas2::transfer( dg::create::dx(g2d), dx);

//discretize the function on the grid and transfer the result to the device
const dg::DVec x = dg::construct<dg::DVec>( dg::evaluate( function, g2d));

//allocate memory for the result
dg::DVec y=x;

//apply the derivative to x and store result in y
dg::blas2::symv(dx, x,y);

//or equivalently
dg::blas2::symv(1., dx, x, 0., y);
@endcode
*/
